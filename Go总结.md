# 环境相关

# 变量与数据结构

## 变量声明

### 显示声明

```go
// var 变量名 类型
var str string
```

- 初始化为零值
- 接口、引用类型（slice、指针、map、chan、func）初始值为 `nil`

### 推导

- 初始化表达式

```go
// var 变量名 = 表达式
var b, f, s = true, 2.3, "four" // bool, float64, string
```

- `:=`推导

```go
// 变量名 := 表达式
i := 100                  // an int
```

## Go数据类型

### 基本数据类型

#### 整型

- Go提供了有符号和无符号类型的整数运算。有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型
- 还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，**但是不能对此做任何的假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小**
- `byte`也是`uint8`类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数
- 无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针

#### 浮点数

- Go提供了两种精度的浮点数，float32和float64,它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持
- 一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；**通常应该优先使用float64类型**，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：

#### 复数

- Go提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部

	```go
	var x complex128 = complex(1, 2) // 1+2i
	var y complex128 = complex(3, 4) // 3+4i
	fmt.Println(x*y)                 // "(-5+10i)"
	fmt.Println(real(x*y))           // "-5"
	fmt.Println(imag(x*y))           // "10"
	```

	

- 如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0

	```go
	fmt.Println(1i * 1i) // "(-1+0i)", i^2 = -1
	```

#### 布尔型

- 布尔类型的值只有两种：true和false

#### 字符串

- 一个字符串是一个**不可改变**的字节序列。字符串可以包含任意的数据，包括byte值0。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。

	> **不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的**。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存
	>
	> ![img](img/ch3-04.png)

- 内置的len函数可以返回一个字符串中的**字节数目**（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足`0 ≤ i< len(s)`条件约束。

- 子字符串操作`s[i:j]`基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串【不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置】

- `+`操作符将两个字符串连接构造一个新字符串

##### 字符串和 Byte 切片

标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包:

- strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
- bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效
- strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
- unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串



一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改.字符串和字节slice之间可以相互转换：

```go
s := "abc"
b := []byte(s)
s2 := string(b)
```

#### 常量

- 常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。



### 复合数据类型

